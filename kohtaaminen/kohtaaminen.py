# -*- coding: utf-8 -*-
# pylint: disable=expression-not-assigned,line-too-long
"""Meeting, rendezvous, confluence (Finnish kohtaaminen) mark up, down, and up again. API."""
import itertools
import os
import pathlib
import re
import shutil
import sys
import tempfile
import zipfile
from typing import List, Optional, Tuple, Union

import mdformat
import pypandoc  # type: ignore

DEBUG_VAR = 'KOHTAAMINEN_DEBUG'
DEBUG = os.getenv(DEBUG_VAR)

ENCODING = 'utf-8'
ENCODING_ERRORS_POLICY = 'ignore'

STDIN, STDOUT = 'STDIN', 'STDOUT'
DISPATCH = {
    STDIN: sys.stdin,
    STDOUT: sys.stdout,
}

MD_ROOT = pathlib.Path('kohtaaminen-md')


def verify_request(argv: Optional[List[str]]) -> Tuple[int, str, List[str]]:
    """Fail with grace."""
    if not argv or len(argv) != 2:
        return 2, 'received wrong number of arguments', ['']

    command, inp = argv

    if command not in ('translate'):
        return 2, 'received unknown command', ['']

    if inp:
        in_path = pathlib.Path(str(inp))
        if not in_path.is_file():
            return 1, f'source ({in_path}) is no file', ['']
        if not ''.join(in_path.suffixes).lower().endswith('.zip'):
            return 1, 'source has not .zip extension', ['']

    return 0, '', argv


def filter_index(data: List[str]) -> str:
    """WIP."""
    less_noisy_lines = ['# Index']
    noise_end_token, noise_end_seen = '## Available Pages:', False
    for line in data:
        if noise_end_seen:
            less_noisy_lines.append(line)
        else:
            noise_end_seen = line.startswith(noise_end_token)
    text = '\n'.join(
        line for line in itertools.takewhile(lambda x: 'Document generated by ' not in x, less_noisy_lines)
    )
    text = re.sub(r'\n\s*\n', '\n\n', text)  # squeeze space-only and blank lines
    text = text.lstrip('\n')  # no leading new lines
    text = text.rstrip('\n') + '\n'  # single new line at end of file
    return text


def filter_leaf(data: List[str], assets: List[str]) -> str:
    """WIP."""
    lines = [line for line in data if 'Created by <span class="author"> ' not in line]
    for ndx, line in enumerate(lines):
        if '# <span id="title-text">' in line:
            prefix, title_plus = line.split('# <span id="title-text">', 1)
            title = title_plus.strip().rstrip('</span>').strip()
            lines[ndx] = f'{prefix}# {title}'
        elif line.startswith('``` syntaxhighlighter-pre'):
            lines[ndx] = '```'
        elif '"><img src="' in line:
            later_head, image_tail = line.split('"><img src="', 1)
            later = f'{later_head}>\n'
            src, rest = image_tail.split('" ', 1)
            if src not in assets:
                assets.append(src)
            try:
                _, height_plus = rest.split('data-height="', 1)
                height, width_plus = height_plus.split('" data-width="', 1)
                width, _ = width_plus.split('" ', 1)
            except ValueError as err:
                print(' ... note: survived image parsing with crash, using defaults. details:', err)
                height, width, center = '42', '42', False
            center = 'image-center' in line
            span_tail = line.endswith('</span>')
            attributes = f'width:{width}, height:{height}, center:{"true" if center else "false"}'
            image = f'![]({src}){{{attributes}}}'
            lines[ndx] = later + image
            if span_tail:
                lines[ndx] += '\n</span>'

    resplit = []
    for line in lines:
        if '\n' not in line:
            resplit.append(line)
        else:
            for lin in line.split('\n'):
                resplit.append(lin)
    lines = [
        line
        for line in resplit
        if not line.startswith('<span') and not line.startswith('class="') and line.strip() != '</span>'
    ]
    lines = [line for line in itertools.takewhile(lambda x: 'Document generated by ' not in x, lines)]
    text = '\n'.join(line for line in itertools.takewhile(lambda x: not x.startswith('## Attachments:'), lines))
    text = re.sub(r'\n\s*\n', '\n\n', text)  # squeeze space-only and blank lines
    text = text.lstrip('\n')  # no leading new lines
    text = text.rstrip('\n') + '\n'  # single new line at end of file
    return text


def main(argv: Union[List[str], None] = None) -> int:
    """Drive the translation."""
    error, message, strings = verify_request(argv)
    if error:
        print(message, file=sys.stderr)
        return error

    command, inp = strings
    if not zipfile.is_zipfile(inp):
        print('wrong magic number in zipfile')
        return 1

    tasks = []
    with zipfile.ZipFile(inp, 'r') as zipper:
        alerts = []
        print(f'analyzing zip file listing of ({inp})')
        for name in zipper.namelist():
            if not name[0].isidentifier() or '..' in name:
                alerts.append(f'suspicious entry ({name}) will be skipped')
        if alerts:
            print(f'found {len(alerts)} suspicious entries in zip file ({inp}):')
            for alert in alerts:
                print(f'- {alert}')
            # return 1

        asset_source_root = ''
        assets: List[str] = []
        with tempfile.TemporaryDirectory() as unpack:
            print(f'unpacking zip file below ({unpack})')
            zipper.extractall(path=unpack)
            print(f'traversing folder ({unpack})')
            for place in sorted(pathlib.Path(unpack).glob('**')):
                print(f'* {place}')
                for thing in sorted(place.iterdir()):
                    if thing.is_dir():
                        if not asset_source_root and thing.name == 'attachments':
                            asset_source_root = str(thing.parent)
                        continue
                    if thing.suffixes[-1] == '.html':
                        tasks.append(thing)
                    print(f'  - {thing}')

            out_root = MD_ROOT
            print(f'translating html tree from ({inp if inp else STDIN}) into markdown tree below {out_root}')

            start = None
            for task in tasks:
                if task.name == 'index.html':
                    start = task
                    break

            for task in tasks:
                marker = ' *' if task == start else ''
                print(f'- {task}{marker}')

            if not start:
                print('did not find start target')
                return 1

            index_path = out_root / 'index.md'
            index_path.parent.mkdir(parents=True, exist_ok=True)
            pypandoc.convert_file(str(start), 'gfm', outputfile=str(index_path))
            with open(index_path, 'rt', encoding=ENCODING) as handle:
                text = filter_index(
                    [line.rstrip() for line in handle.readlines() if '</div>' not in line and '<div ' not in line]
                )
            with open(index_path, 'wt', encoding=ENCODING) as handle:
                handle.write(text)

            for task in tasks:
                if task == start:
                    continue
                task_path = out_root / task.name.replace('html', 'md')
                pypandoc.convert_file(str(task), 'gfm', outputfile=str(task_path))
                with open(task_path, 'rt', encoding=ENCODING) as handle:
                    text = filter_leaf(
                        [line.rstrip() for line in handle.readlines() if '</div>' not in line and '<div ' not in line],
                        assets,
                    )
                with open(task_path, 'wt', encoding=ENCODING) as handle:
                    handle.write(text + '\n')

            # Push the media assets (so the md format does not remove the links)
            if assets:
                nr_assets = len(assets)
                print(f'imported {nr_assets} distinct asset{"" if nr_assets == 1 else "s"}:')
                for asset in assets:
                    print(f'- {asset}')
                    asset_source = pathlib.Path(asset_source_root) / asset
                    asset_path = out_root / asset
                    asset_path.parent.mkdir(parents=True, exist_ok=True)
                    try:
                        shutil.copyfile(asset_source, asset_path)
                    except FileNotFoundError as err:
                        print(' ... note: survived wrongly parsed file source path on shutil copy. details:', err)

            # Format the markdown
            for task in tasks:
                task_path = out_root / task.name.replace('html', 'md')
                mdformat.file(task_path, options={'number': True, 'wrap': 142})

            print(f'markdown tree is below ({out_root})')

    return 0
